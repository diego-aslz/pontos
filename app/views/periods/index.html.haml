- title l(@base, format: '%B/%Y')

.months
  .left
    = link_to_month t(:previous_month), @base.prev_month
    %br
    = formatted_time PeriodComputer.new(nil, @base.change(day:1).yesterday).balance
  .mid
    = link_to_month t(:current_month), Date.today
    %br
    = formatted_time PeriodComputer.new(nil, nil).balance
  .right
    = link_to_month t(:next_month), @base.next_month

%table.horaries-table
  - # FIRST TABLE HEADING
  %tr
    %th{colspan: 2}
    %th{colspan: 3}=t :morning
    %th{colspan: 3}=t :afternoon
    %th{colspan: 3}
  - # SECOND TABLE HEADING
  %tr
    %th{colspan: 2}= Period.human_attribute_name :day
    %th= Period.human_attribute_name :start
    %th= Period.human_attribute_name :finish
    %th.tiny
    %th= Period.human_attribute_name :start
    %th= Period.human_attribute_name :finish
    %th.tiny
    %th= t :expected
    %th= t :worked
    %th= t :balance
  - month = Date.new(@base.year, @base.month, -1)
  - last = month.day
  - 1.upto last do |day|
    - month = month.change day: day
    - morning = periods_for(@periods, day, true).first
    - afternoon = periods_for(@periods, day).first
    - # TABLE CONTENT
    - if month.sunday? || month.saturday?
      - # WEEKEND
      %tr.weekend
        %td.day= l month, format: '%a'
        %td.day= l month, format: '%d'
        %td{colspan: 9}
    - else
      - # COMMON DAYS
      - computer = PeriodComputer.new(month)
      %tr
        %td.day= l month, format: '%a'
        %td.day= l month, format: '%d'
        = show_period morning, month, true
        = show_period afternoon, month
        %td= formatted_time computer.expected_time
        %td= formatted_time computer.worked_time
        %td= formatted_time computer.balance
